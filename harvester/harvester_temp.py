from confluent_kafka import Consumer
from confluent_kafka import Producer
from datetime import datetime
import time
import random
import logging as logger
consumer = Consumer({'bootstrap.servers':'kafka:9092', 'auto.offset.reset':'latest', 'group.id': 'HarvesterPipeline1'})
producer = Producer({'bootstrap.servers':'kafka:9092'})

logger.basicConfig(level=logger.DEBUG)


def consume_from_topic(self, consumer):
    poll = {}
    while not poll:
        poll = consumer.poll()
    
    msg_list = poll[list(poll)[-1]]
    for msg in msg_list:
        logger.info(msg)

    return (msg_list[-1])

while True:
    try:
        msg = consumer.consume()
        if msg:
            Finish = False
            tstamp = datetime.now()
            logger.info("Received message {}".format(msg.value))
            producer.produce(topic='gRPC', value=b'This message was generated by the Harvester and was read from the gRPC topic %s.' % bytes(str(tstamp), 'utf-8'))
            logger.info(b'This message was generated by the Harvester and was read from the gRPC topic %s.' % bytes(str(tstamp), 'utf-8'))
            for i in range(0,10):
                time.sleep(5)
                tstamp = datetime.now()
                if random.random() < 0.6: 
                    producer.produce(topic='gRPC', value=b'Error') 
                    logger.info(b'Error')
                    Finish = True
                    break
                producer.send(topic='gRPC', value=b'This message was generated by the Harvester and was read from the gRPC topic %s.' % bytes(str(tstamp), 'utf-8'))
                logger.info(b'This message was generated by the Harvester and was read from the gRPC topic %s.' % bytes(str(tstamp), 'utf-8'))
            if not Finish:
                producer.send(topic='gRPC', value=b'Done %s.' % bytes(str(tstamp), 'utf-8'))
                tstamp = datetime.now()            
                logger.info(b'Done %s.' % bytes(str(tstamp), 'utf-8'))


    except:
        logger.info("No new messages")
        time.sleep(2)
        continue

