from harvester.metadata.arxiv_harvester import ArXiV_Harvester, arxiv_harvesting
from base import MockListRecords
from harvester import utils, db
from harvester.harvester import Harvester_APP
from confluent_kafka.avro import AvroProducer
from mockschemaregistryclient import MockSchemaRegistryClient
from unittest import TestCase
import pickle
import requests
import pytest
import boto3
import moto
import base
from mock import patch

@pytest.fixture
def empty_bucket():
    """
    Generates an empty S3 bucket using the moto mocking framework.
    """
    moto_fake = moto.mock_s3()
    try:
        moto_fake.start()
        conn = boto3.resource('s3')
        conn.create_bucket(Bucket="test-bucket-name")  # or the name of the bucket you use
        yield conn
    finally:
        moto_fake.stop()

class test_ArXiV_Harvester(TestCase):
    def test_arxiv_harvester_from(self):
        with MockListRecords():
            arxiv_harvester = ArXiV_Harvester(harvest_url='https://export.arxiv.org/oai2', daterange='2023-03-07', resumptionToken=None)
            with open('tests/data/ListRecords_data_0.xml', 'r+') as f:
                response_text = f.read()    
            self.assertEqual(arxiv_harvester.raw_xml, response_text)
    
    def test_arxiv_harvester_resumptionToken(self):
        with MockListRecords():
            arxiv_harvester = ArXiV_Harvester(harvest_url='https://export.arxiv.org/oai2', daterange=None, resumptionToken='6511260|1001')
            with open('tests/data/ListRecords_data_1.xml', 'r+') as f:
                response_text = f.read()    
            self.assertEqual(arxiv_harvester.raw_xml, response_text)

    def test_arxiv_harvester_resumptionToken_retry_after(self):
        with MockListRecords(error_503=True):
            with pytest.raises(requests.exceptions.Timeout):
                ArXiV_Harvester(harvest_url='https://export.arxiv.org/oai2', daterange=None, resumptionToken='6511260|1001')
        
    def test_arxiv_harvester_generator(self):
        with MockListRecords():
            arxiv_harvester = ArXiV_Harvester(harvest_url='https://export.arxiv.org/oai2', daterange='2023-03-07', resumptionToken=None)
            harvested_records = []
            for record in arxiv_harvester:
                harvested_records.append(record)
            with open('tests/data/parsed_records.pkl', 'rb') as f:
                test_records = pickle.load(f)
            self.assertEqual(2265, len(harvested_records))
            self.assertEqual(harvested_records, test_records)
    
    @moto.mock_s3
    def test_arxiv_harvesting_main(self):
        mock_job_request = {"task_args":{"daterange":"2023-03-07", "resumptionToken": None}, "task": "ARXIV"}
        with base.base_utils.mock_multiple_targets({'get_schema': patch.object(utils, 'get_schema', return_value = '{"type":"record","name":"HarvesterMetadataOutput","fields":[{"name":"record_id","type":["string","null"],"doc":"The job ID generated by storing it in postgres.","logicalType":"uuid"},{"name":"record_xml","type":["string","null"],"doc":"The Harvested XML for a given record."},{"name":"task","type":{"type":"enum","name":"taskenum","symbols":["ARXIV","ELSEVIER","IOP","SIMBAD","MONITOR"]},"doc":"An enumerated type for specifying the harvester data source."}]}'), \
            'write_harvester_record': patch.object(db, 'write_harvester_record', return_value = True)}) as mocked:
            mock_app = Harvester_APP(proj_home='tests/data')
            mock_app.schema_client = MockSchemaRegistryClient()
            producer = AvroProducer({}, schema_registry=mock_app.schema_client)
            with moto.mock_s3():
                bucket = 'test-bucket-name'
                conn = boto3.resource("s3")
                conn.create_bucket(Bucket=bucket)
            with MockListRecords():
                arxiv_harvesting(mock_app, mock_job_request, producer)
            self.assertTrue(mocked['get_schema'].called)
            self.assertTrue(mocked['write_harvester_record'].called)

